// Utils:
import _ from "lodash";

import {
  ManualOverride,
  ParamPrefixesType,
  ParamPrefixes,
} from "../FilterModels";
import {
  IndivStatSet,
  Statistic,
  TeamStatSet,
  LineupStatSet,
  OnOffBaselineEnum,
} from "../StatModels";

/** Utilities for managing luck or manual overrides to individual/team stats */
export class OverrideUtils {
  // Top level

  /** Apply any generated overrides to a player
   * See also RatingUtils.buildOverrides, which is tightly coupled to this
   */
  static readonly applyOverrides = (
    stat: IndivStatSet,
    onOffKey: "On" | "Off" | "Baseline" | "Global",
    manualOverridesAsMap: Record<string, Record<string, number>>,
    adjustForLuck: boolean
  ) => {
    const playerOverrideKey = OverrideUtils.getPlayerRowId(stat.key, onOffKey);
    const overrides = manualOverridesAsMap[playerOverrideKey];
    const overrodeOffFields = _.reduce(
      OverrideUtils.playerOverridableStatsList,
      (acc, statName) => {
        const override = overrides?.[statName];

        if (
          _.isNil(override) &&
          overrides?.hasOwnProperty(
            OverrideUtils.keyToShotQualityKey(statName) || ""
          )
        ) {
          return acc; //(if there is an SQ override and not a normal one then don't unset the SQ one)
        } else {
          const maybeDoOverride = OverrideUtils.overrideMutableVal(
            stat,
            statName,
            override,
            "Manually adjusted"
          );
          return acc || maybeDoOverride;
        }
      },
      false
    );

    const adjustmentReason = (() => {
      if (adjustForLuck && overrodeOffFields) {
        return "Derived from luck adjustments and manual overrides";
      } else if (!adjustForLuck && overrodeOffFields) {
        return "Derived from manual overrides";
      } else if (adjustForLuck && !overrodeOffFields) {
        return "Luck adjusted";
      } else {
        return undefined;
      }
    })();
    // Set or unset derived stats:
    OverrideUtils.updateDerivedStats(stat, adjustmentReason);

    return [adjustmentReason, overrodeOffFields] as [
      string | undefined,
      boolean
    ];
  };

  // Lower level

  /** Returns the original value regardless of whether it's overridden or not */
  private static readonly getOriginalVal = (
    mutableVal: Statistic
  ): number | undefined => {
    return _.isNil(mutableVal?.old_value)
      ? mutableVal?.value
      : mutableVal?.old_value;
  };

  /** If the old value was nil we leave it alone */
  private static readonly getIgnoreNil = (val: Statistic) =>
    _.isNil(val?.old_value) ? { value: undefined } : val;

  /** Shared format for individual override row ids */
  static readonly getPlayerRowId = (
    playerId: string,
    rowSubType: "On" | "Off" | "Baseline" | "Global"
  ) => {
    return `${playerId} / ${rowSubType}`;
  };

  /** For a given table type lists the key/name for stats that we let users overrride */
  static readonly getOverridableStats = (tableType: ParamPrefixesType) => {
    return _.fromPairs(
      (() => {
        switch (tableType) {
          case ParamPrefixes.player:
            return _.sortBy(
              [
                ["off_3p", "Offensive 3P%"],
                ["off_2pmid", "Offensive mid-range 2P%"],
                ["off_2prim", "Offensive rim/dunk 2P%"],
                ["off_ft", "Offensive FT%"],
                //TODO: avoid rate stats for now ... longer term would like to be able to say
                // more mid-range shots, more rim shots, etc and can also include FTR then
                //        [ "off_ftr", "Offensive FT rate" ],
                ["off_to", "Offensive TO%"],
              ],
              [(o: any[]) => o[1]]
            );
          default:
            return [];
        }
      })()
    );
  };

  /** Convert the list of overrides into a map of maps of numbers */
  static readonly buildOverrideAsMap = (overrides: ManualOverride[]) => {
    return _.transform(
      overrides,
      (acc, over) => {
        if (over.use) {
          const maybePlayer = acc[over.rowId] || {};
          maybePlayer[over.statName] = over.newVal;
          acc[over.rowId] = maybePlayer;
        }
      },
      {} as Record<string, Record<string, number>>
    );
  };

  /** When converting from individual manual adjustments to team adjustments, these are the weights to use */
  static readonly overrideFieldToWeightField: Record<string, string> = {
    off_3p: "total_off_3p_attempts",
    off_2pmid: "total_off_2pmid_attempts",
    off_2prim: "total_off_2prim_attempts",
    off_ft: "total_off_fta",
    off_to: "total_off_to",
  };

  /** Clear changes to team stats generated by manual team overrides */
  static readonly clearTeamManualOrLuckOverrides = (
    mutableTeamStats: TeamStatSet
  ) => {
    _.keys(OverrideUtils.getOverridableStats(ParamPrefixes.player))
      .concat([
        "off_ppp",
        "off_adj_ppp",
        "off_net",
        "off_raw_net",
        "off_efg",
        "off_2p", //(derived values for manual/luck)
        "def_ppp",
        "def_adj_ppp",
        "def_3p",
        "def_efg", //(derived values for luck only)
      ])
      .forEach((key) => {
        mutableTeamStats[key] = {
          value: OverrideUtils.getOriginalVal(mutableTeamStats[key]),
          extraInfo: mutableTeamStats[key]?.extraInfo,
        };
      });
  };

  /** filter out overrides we don't care about and strip rowId down to player key */
  static readonly filterManualOverrides = (
    queryKey: OnOffBaselineEnum,
    overrides?: ManualOverride[]
  ) => {
    return (overrides || [])
      .filter((o) => o.use)
      .flatMap((override) => {
        // Step 1: filter out overrides we don't care about and strip rowId down to player key
        const playerQuery = override.rowId.split(" / ");
        const playerKey = playerQuery[0];
        const overrideQueryKey = playerQuery?.[1] || "";

        if (playerQuery.length < 2 || _.toLower(overrideQueryKey) != queryKey) {
          return [];
        } else {
          return [{ ...override, rowId: playerKey }];
        }
      });
  };

  /** Applies individual stats to the team - TODO doesn't currently handle luck */
  static readonly applyPlayerOverridesToTeam = (
    queryKey: OnOffBaselineEnum,
    overrides: ManualOverride[],
    playerStats: Record<string, IndivStatSet>,
    mutableTeamStats: TeamStatSet,
    averageEff: number,
    adjustForLuck: Boolean
  ) => {
    // Apply overrides

    const adjustStat = (
      mutableStat: Statistic | undefined,
      delta: number,
      over: ManualOverride,
      notIfLuckAdj: Boolean = false
    ) => {
      if (mutableStat && _.isNumber(mutableStat.value)) {
        const existingVal = mutableStat.value;
        if (!notIfLuckAdj) {
          //(if luck adjusting, the aggregate params will be written by LuckUtils)
          mutableStat.value = existingVal + delta;
          if (_.isNil(mutableStat.old_value)) {
            mutableStat.old_value = existingVal;
          }
        }
        const existingOverride = mutableStat.override;
        const isPct = existingVal <= 1.0 && existingVal >= 0.0;
        const formattedDelta = isPct
          ? (delta * 100).toFixed(1)
          : delta.toFixed(1);
        const newOverrideStr = `Adjusted by [${formattedDelta}] for [${
          over.rowId
        }] override of [${over.statName}] to [${100 * over.newVal}]%`;
        if (existingOverride && _.isString(existingOverride)) {
          mutableStat.override = existingOverride + " // " + newOverrideStr;
        } else if (!existingOverride) {
          mutableStat.override = newOverrideStr;
        } //(else it's HTML so just leave it alone)
      }
    };
    OverrideUtils.filterManualOverrides(queryKey, overrides).forEach(
      (override) => {
        const player = playerStats[override.rowId];

        if (player) {
          const deltaStat =
            (player[override.statName]?.value || 0) -
            (player[override.statName]?.old_value || 0);

          const weightField =
            OverrideUtils.overrideFieldToWeightField[override.statName];
          if (
            weightField &&
            mutableTeamStats[weightField] &&
            player[weightField]
          ) {
            const weightedDelta =
              (player[weightField].value || 0) /
              (mutableTeamStats[weightField].value || 1);
            adjustStat(
              mutableTeamStats[override.statName],
              weightedDelta * deltaStat,
              override,
              false
            );

            // If adjusting the 2P shooting then adjust aggregate 2P% (used in Luck calcs)
            if (
              "off_2pmid" == override.statName ||
              "off_2prim" == override.statName
            ) {
              const twoPtFgWeight = "total_off_2p_attempts";
              const weightedEfgDelta =
                (player[weightField].value || 0) /
                (mutableTeamStats[twoPtFgWeight]?.value || 1);
              adjustStat(
                mutableTeamStats["off_2p"],
                weightedEfgDelta * deltaStat,
                override,
                false
              );
            }
          }
          // ORtg -> unadjusted efficiency
          const deltaORtg =
            (player.off_rtg?.value || averageEff) -
            (player.off_rtg?.old_value || averageEff);
          const playerUsg = player.off_usage?.value || 0;
          const playerPossPct = player.off_team_poss_pct?.value || 0;

          const possUsgWeight = playerUsg * playerPossPct;
          const offPppDelta = possUsgWeight * deltaORtg;
          adjustStat(
            mutableTeamStats.off_ppp,
            offPppDelta,
            override,
            adjustForLuck
          );

          // Take player SoS into account to get adjusted efficiency
          const playerDefSos = player.def_adj_opp?.value || averageEff;
          const adjustedOffPppDelta = offPppDelta * (averageEff / playerDefSos);
          adjustStat(
            mutableTeamStats.off_adj_ppp,
            adjustedOffPppDelta,
            override,
            adjustForLuck
          );

          // eFG
          if (_.endsWith(weightField, "_attempts")) {
            //(ie adjusted a shot, not TO% / FT%)
            const eFgWeight = "total_off_fga";
            const eFgDeltaStat =
              (player.off_efg?.value || 0) - (player.off_efg?.old_value || 0);
            const weightedEfgDelta =
              (player[eFgWeight]?.value || 0) /
              (mutableTeamStats[eFgWeight]?.value || 1);
            adjustStat(
              mutableTeamStats["off_efg"],
              weightedEfgDelta * eFgDeltaStat,
              override,
              adjustForLuck
            );
          }

          // Adjust the adjusted and raw net margins:

          adjustStat(
            mutableTeamStats.off_raw_net,
            offPppDelta,
            override,
            adjustForLuck
          );
          adjustStat(
            mutableTeamStats.off_net,
            adjustedOffPppDelta,
            override,
            adjustForLuck
          );
        }
      }
    );
    return mutableTeamStats;
  };

  /** TODO all sorts of complications in terms of when fields get set/unset */
  static readonly handleShotSelection = (
    mutableStats: IndivStatSet | TeamStatSet | LineupStatSet,
    shotSelMap: Record<string, number>,
    reason: string
  ) => {
    if (_.isEmpty(shotSelMap)) {
      const fieldsToReset = [
        // Reset shot rates:
        "off_3pr",
        "off_2primr",
        "off_2pmidr",
        // Reset attempts/makes:
        "total_off_3p_attempts",
        "total_off_3p_made",
        //TODO: other shots types
        // Do NOT override %s, they are handled by the per-field settings
      ];
      fieldsToReset.forEach((fieldToReset) =>
        OverrideUtils.overrideMutableVal(
          mutableStats,
          fieldToReset,
          undefined,
          undefined
        )
      );
    } else {
      //TODO: let's start off assuming 3P is set
      const fgAttempts = mutableStats[`total_off_fga`]?.value || 0;

      const shotType = "3p";
      const shotAdj = shotSelMap[`aggro_${shotType}`] || 1.0;
      const shotAttempts =
        OverrideUtils.getOriginalVal(
          mutableStats[`off_${shotType}_attempts`] //TODO: shotType isn't the same here except for 3P
        ) || 0;
      const shotMakes =
        OverrideUtils.getOriginalVal(
          mutableStats[`total_off_${shotType}_made`]
        ) || 0;
      const shotRate =
        OverrideUtils.getOriginalVal(mutableStats[`off_${shotType}r`]) || 0;
      const newShotRate = Math.min(1.0, shotRate * shotAdj);
      const deltaShotRate = newShotRate - shotRate;
      const deltaShots = fgAttempts * deltaShotRate;

      // There's some weirdness with RatingUtils.buildOffOverrides
      // since that also messes with the totals in order to calc ORtg/usage, which is basically what we're doing here

      // const baseKey = shotSelKey.substring(
      //   OverrideUtils.shotSelectionPrefix.length
      // );
      // const originalShotRate = OverrideUtils.getOriginalVal(
      //   mutableStats[`off_${baseKey}`]
      // );
      //TODO: change total_off_<<key>>_attempts
      //TODO: change off_<<key>>r
      //TODO: change off_<<other-keys>>r
      //TODO: ugh what about if multiple shot rates are adjusted, what a mess
      // .. in practice I think we'll have to do all the shot selections at once
      // .. but to start with probably just play with one param to see this work in concept
      //TODO: change off_<<key>> ... maybe +-10% from current 3P, cap there
    }
  };

  /** Overrides the specified key (newVal undefined means set back), returns true if mutated */
  static readonly overrideMutableVal = (
    mutableStats: IndivStatSet | TeamStatSet | LineupStatSet,
    inKey: string,
    inNewVal: number | { delta: number } | undefined,
    reason: string | undefined
  ) => {
    const key = inKey.startsWith(OverrideUtils.shotQualityPrefix)
      ? `off_${inKey.substring(OverrideUtils.shotQualityPrefix.length)}`
      : inKey;

    const sqIgnoreNil = key != inKey && !inNewVal;
    //(Don't _unset_ an SQ null, that's handled by the non-SQ fields)

    if (!sqIgnoreNil && mutableStats[key]) {
      const originalVal = OverrideUtils.getOriginalVal(mutableStats[key]);

      const newVal =
        OverrideUtils.shotQualityRim == inKey
          ? OverrideUtils.getRimPctFromTs(
              inNewVal as number | undefined,
              mutableStats
            )
          : inNewVal;

      const maybeReason = mutableStats[key]?.override;
      // (don't unset an param that was overridden for a different reason - though empty reason always unsets)
      const noOverwrite =
        _.isNil(newVal) &&
        !_.isNil(maybeReason) &&
        !_.isNil(reason) &&
        maybeReason != reason;
      if (!noOverwrite) {
        mutableStats[key] = _.isNil(newVal)
          ? {
              value: originalVal,
            }
          : OverrideUtils.getIgnoreNil({
              value: _.isNumber(newVal)
                ? newVal
                : (originalVal || 0) + (newVal?.delta || 0),
              old_value: originalVal,
              override: reason,
            });
      }
      return !_.isNil(newVal);
    } else {
      return false;
    }
  };

  /** The delta from the raw value to the override */
  static readonly diff = (val: any) => {
    return _.isNil(val?.old_value) ? 0.0 : (val?.value || 0) - val.old_value;
  };

  /** Where overrides to shooting have occurred, update 4 factors - overwrites any luck values */
  static readonly updateDerivedStats = (
    mutableStats: IndivStatSet,
    reason: string | undefined
  ) => {
    //TODO: this is a bit of a mess ... should handle luck and override derived vals in one place

    const threePR = mutableStats.off_3pr?.value || 0;
    const midR = mutableStats.off_2pmidr?.value || 0;
    const rimR = mutableStats.off_2primr?.value || 0;
    const deltaEfg_3p = threePR * OverrideUtils.diff(mutableStats.off_3p) * 1.5;
    const deltaEfg_2p_mid = midR * OverrideUtils.diff(mutableStats.off_2pmid);
    const deltaEfg_2p_rim = rimR * OverrideUtils.diff(mutableStats.off_2prim);
    const deltaEfg = deltaEfg_3p + deltaEfg_2p_mid + deltaEfg_2p_rim;

    const delta2p = (deltaEfg_2p_mid + deltaEfg_2p_rim) / (1.0 - threePR);
    if (delta2p != 0.0) {
      OverrideUtils.overrideMutableVal(
        mutableStats,
        "off_2p",
        { delta: delta2p },
        reason
      );
    } else {
      //(setting reason as undefined ensures it gets overwritten...
      //... this is desirable because I'm overwriting any luck effects)
      OverrideUtils.overrideMutableVal(
        mutableStats,
        "off_2p",
        undefined,
        undefined
      );
    }
    if (deltaEfg != 0.0) {
      OverrideUtils.overrideMutableVal(
        mutableStats,
        "off_efg",
        { delta: deltaEfg },
        reason
      );
    } else {
      //(always set reason as undefined, see above)
      OverrideUtils.overrideMutableVal(
        mutableStats,
        "off_efg",
        undefined,
        undefined
      );
    }
  };

  // Some utils needed for aggression overrides

  static readonly shotSelectionPrefix = "aggro_";

  // Some utils needed for Shot Quality overrides

  static readonly shotQualityPrefix = "sq_";
  static readonly shotQualityRim = "sq_2prim";
  static readonly shotQualityMid = "sq_2pmid";
  static readonly shotQualityThree = "sq_3p";

  static readonly shotQualityMetricMap: Record<string, string> = {
    [OverrideUtils.shotQualityRim]: "Shot Quality Rim TS%",
    [OverrideUtils.shotQualityMid]: "Shot Quality Mid FG%",
    [OverrideUtils.shotQualityThree]: "Shot Quality 3P FG%",
  };

  /** see getOldRimTs */
  static readonly sqFtWeight = 0.88;

  /**
   * Calculates the rim true shooting from the raw numbers (ie before any overrides)
   * We assume that FTs _all_ come from the rim, since anything else is too complicated
   */
  static readonly getOldRimTs = (statSet: IndivStatSet) => {
    const rimr = statSet.off_2primr?.value || 0; // eg 50% would be 100 2PA (if 200 FGA)
    const rimFtr = statSet.off_ftr?.value || 0; //eg 25% would be 25%*200FGA == 50 FTA, ie 50% rim FTR

    // Example: 100 FGA: 30 2PAs (30% rimr) + 20 FTA (20% ftr) ... 15 FGM + 15 FTM => 45pts / 2*(30 + 0.44*20) => 45/70 ~= 65%
    // We use 88% of both FTA/FTR because a) we only care about 2FTs, b) some of the FTs are 3P/bonus

    const weight = OverrideUtils.sqFtWeight;
    const ftPct = OverrideUtils.getOriginalVal(statSet.off_ft || {}) || 0;

    const ts =
      (2 * rimr * (OverrideUtils.getOriginalVal(statSet.off_2prim || {}) || 0) +
        weight * rimFtr * ftPct) /
      (2 * rimr + weight * rimFtr);

    return ts;
  };

  /** Opposite of getOldRimTs */
  private static readonly getRimPctFromTs = (
    ts: number | undefined,
    statSet: IndivStatSet | TeamStatSet | LineupStatSet
  ) => {
    const rimr = statSet.off_2primr?.value || 0; // eg 50% would be 100 2PA (if 200 FGA)
    const rimFtr = statSet.off_ftr?.value || 0; //eg 25% would be 25%*200FGA == 50 FTA, ie 50% rim FTR

    const weight = OverrideUtils.sqFtWeight;
    const ftPct = OverrideUtils.getOriginalVal(statSet.off_ft || {}) || 0;

    const newRim = ts
      ? (ts * (2 * rimr + weight * rimFtr) - weight * rimFtr * ftPct) /
        (2 * rimr || 1)
      : 0;

    return newRim;
  };

  /** Switches from sq_ to the corresponding stat set key */
  static readonly shotQualityKeyToKey = (key: string) => {
    const statNameKey = key.startsWith(OverrideUtils.shotQualityPrefix)
      ? `off_${key.substring(OverrideUtils.shotQualityPrefix.length)}`
      : key;
    return statNameKey;
  };

  /** Switches from sq_ to the corresponding stat set key */
  static readonly keyToShotQualityKey = (key: string): string | undefined => {
    const candidate = `sq_${key.substring(4)}`;
    const sqKey = OverrideUtils.shotQualityMetricMap[candidate];
    return sqKey ? candidate : undefined;
  };

  // Some constants

  static readonly playerOverridableStatsList = _.keys(
    OverrideUtils.shotQualityMetricMap
  ).concat(_.keys(OverrideUtils.getOverridableStats(ParamPrefixes.player))); //(do SQ first, _then_ manual overrides)
}
